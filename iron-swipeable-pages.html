<link rel="import" href="../polymer/polymer.html">

<!--
An element providing a solution to no problem in particular.

Example:

    <iron-swipeable-pages></iron-swipeable-pages>

Example:

    <iron-swipeable-pages>
      <h2>Hello iron-swipeable-pages</h2>
    </iron-swipeable-pages>

@demo demo/index.html
@hero hero.svg
-->

<dom-module id="iron-swipeable-pages">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <content id="content"></content>
  </template>

  <script>
    Polymer({
      is: 'iron-swipeable-pages',

      behaviors: [
        Polymer.IronResizableBehavior,
        Polymer.IronSelectableBehavior
      ],

      properties: {
        /**
         * We make this property readonly so changing page only occurs when
         * page are swiped or selectNext() or selectPrevious() is called.
         */
        selected: {
          type: String,
          notify: true
        },

        /**
         * Describes the author of the element, but is really just an excuse to
         * show off JSDoc annotations.
         *
         * @type {{name: string, image: string}}
         */
        author: {
          type: Object,
          // Use `value` to provide a default value for a property, by setting it
          // on your element's prototype.
          //
          // If you provide a function, as we do here, Polymer will call that
          // _per element instance_.
          //
          // We do that to ensure that each element gets its own copy of the
          // value, rather than having it shared across all instances (via the
          // prototype).
          value: function() {
            return {
              name:  'Dimitri Glazkov',
              image: 'http://addyosmani.com/blog/wp-content/uploads/2013/04/unicorn.jpg',
            };
          }
        },

        /**
         * The CSS transition applied while swiping.
         */
        transition: {
          type: String,
          value: '300ms cubic-bezier(0.4, 0.0, 0.2, 1)'
        }
      },

      // Element Lifecycle

      ready: function() {
        this._transitionProperty = 'opacity, transform';
        this._swipeComplete = false;
        this._direction = '';
      },

      attached: function() {
        this._nodeObserver = Polymer.dom(this.$.content).observeNodes(
            function(mutations) {
              for (var i = 0; i < mutations.addedNodes.length; i++) {
                this._addListeners(mutations.addedNodes[i]);
              }
              for (var i = 0; i < mutations.removedNodes.length; i++) {
                this._removeListeners(mutations.removedNodes[i]);
              }
            }.bind(this));
      },

      _addListeners: function(node) {
        if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.COMMENT_NODE)
          return;
        // Set up the animation.
        node.style.transitionProperty = this._transitionProperty;
        node.style.transition = this.transition;

        this.listen(node, 'track', '_onTrack');
        this.listen(node, 'transitionend', '_onTransitionEnd');
      },

      _removeListeners: function(node) {
        if (node.nodeType === Node.TEXT_NODE)
          return;
        this.unlisten(node, 'track', '_onTrack');
        this.unlisten(node, 'transitionend', '_onTransitionEnd');
      },

      detached: function() {
        if (this._nodeObserver) {
          Polymer.dom(this.$.content).unobserveNodes(this._nodeObserver);
          this._nodeObserver = null;
        }
      },

      // Element Behavior

      _onTrack: function(event) {
        var target = event.currentTarget;
        var track = event.detail;

        if (track.state === 'start') {
          this._trackStart(track, target);
        } else if (track.state === 'track') {
          this._trackMove(track, target);
        } else if (track.state === 'end') {
          this._trackEnd(track, target);
        }
      },

      _trackStart: function(event, target) {
        // Save the width of the element, so that we don't trigger a style
        // recalc every time we need it.
        this._nodeWidth = target.offsetWidth;
        target.style.transition = 'none';
      },

      _trackMove: function(event, target) {
        this._animate(event.dx, target);
      },

      _trackEnd: function(event, target) {
        // The element is swiped away if it's moved halfway its total width.
        this._swipeComplete = Math.abs(event.dx) > this._nodeWidth / 2;
        this._direction = event.dx > 0;
        this._swipeEnd(target);
      },

      _animate: function(x, target) {
        var direction = x > 0 ? 1 : -1;

        // This is the total distance the animation will take place over.
        var totalDistance = this._nodeWidth * this.widthRatio;

        // Opacity distance overflow. `this._nodeWidth * this.opacityRate` is the
        // total distance the element needs to travel to become completely
        // transparent, and `x` is how much the element has already travelled.
        var opaqueDistance = Math.max(0, Math.abs(x) - this._nodeWidth * this.opacityRate);
        var opacity = Math.max(0, (totalDistance - opaqueDistance) / totalDistance);
        target.style.opacity = opacity;

        var translate, rotate;

        if (this.swipeStyle === 'horizontal') {
          translate = 'translate3d(' + x + 'px,' + 0 + 'px,0)';
          rotate = '';
        } else {  // Default is assumed to be `curve`.
          // Assume the element will be completely transparent at 90 degrees, so
          // figure out the rotation and vertical displacement needed to
          // achieve that.
          var y = totalDistance - Math.sqrt(totalDistance * totalDistance - opaqueDistance * opaqueDistance);
          var deg = (1 - opacity) * direction * 90;

          translate = 'translate3d(' + x + 'px,' + y + 'px,0)';
          rotate = ' rotate(' + deg + 'deg)';
        }

        this.transform(translate + rotate, target);
      },

      _swipeEnd: function(target) {
        // Restore the original transition;
        target.style.transition = this.transition;

        if (this._swipeComplete) {
          // If the element is ready to be swiped away, then translate it to the full
          // transparency distance.
          var totalDistance = this._nodeWidth * this.widthRatio;
          this._animate(this._direction ? totalDistance : -totalDistance, target);
        } else {
          this._animate(0, target);
        }
      },

      _onTransitionEnd: function(event) {
        var target = event.currentTarget;

        if (this._swipeComplete && event.propertyName === 'opacity') {
          Polymer.dom(this).removeChild(target);
          this.fire('iron-swipe',
              { direction: this._direction > 0 ? 'right' : 'left',
                target:target
              });
        }
      }
    });
  </script>
</dom-module>
