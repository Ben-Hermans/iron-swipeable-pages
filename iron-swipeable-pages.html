<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../iron-selector/iron-selectable.html">

<!--
An element providing a solution to no problem in particular.

Example:

    <iron-swipeable-pages selected="0">
      <div>One</div>
      <div>Two</div>
      <div>Three</div>
    </iron-swipeable-pages>

@demo demo/index.html
@hero hero.svg
-->

<dom-module id="iron-swipeable-pages">
  <style>
    :host {
      display: block;
      position: relative;
      overflow-x: hidden;
    }
    :host > ::content > * {
      position: absolute;
      top: 0;
      width: 100%;
      height: 100%;
    }
    :host > ::content > :not(.iron-selected):not(.iron-swiping) {
      display: none !important;
    }

    :host > ::content > .iron-swiping {
      pointer-events: none;
    }
  </style>

  <template>
    <content id="content"></content>
  </template>

  <script>
    (function() {
      Polymer({
        is: 'iron-swipeable-pages',

        behaviors: [
          Polymer.IronResizableBehavior,
          Polymer.IronSelectableBehavior
        ],

        properties: {
          // as the selected page is the only one visible, activateEvent
          // is both non-sensical and problematic; e.g. in cases where a user
          // handler attempts to change the page and the activateEvent
          // handler immediately changes it back
          activateEvent: {
            type: String,
            value: null
          },

          /**
           * The value used to decide if a transition is effective and therefore
           * if the page get swiped.
           */
          threshold: {
            type: Number,
            value: 0.05
          },

          /**
           * The CSS transition duration applied while swiping.
           */
          transitionDuration: {
            type: Number,
            value: 300
          },

          /**
           * The CSS transition duration applied while swiping.
           */
          transitionTimingFunction: {
            type: String,
            value: 'cubic-bezier(0.4, 0.0, 0.2, 1)'
          }

          // TODO PG: add an option to avoid cycling
        },

        listeners: {
          'iron-items-changed': '_onItemsChanged',
          'track': '_onTrack'
        },

        observers: [
          '_onSelectedChanged(selected)'
        ],

        // Element Lifecycle
        ready: function() {
          console.log("boing...");
          this._swipeComplete = false;
          this._lastIndex = this._valueToIndex(this.selected);
          // this._animatedPages = [];
        },

        attached: function() {
          this._width = this.offsetWidth;
        },

        // Element Behavior
        _onItemsChanged: function(event) {
          var mutations = event.detail;
          for (var i = 0; i < mutations.addedNodes.length; i++) {
            this._addPage(mutations.addedNodes[i]);
          }
          for (var j = 0; j < mutations.removedNodes.length; j++) {
            this._removePage(mutations.removedNodes[j]);
          }
        },

        _addPage: function(page) {
            if (page.nodeType !== Node.ELEMENT_NODE)
              return;
            this.listen(page, 'transitionend', '_onTransitionEnd');
        },

        _removePage: function(page) {
            if (page.nodeType !== Node.ELEMENT_NODE)
              return;
            this.unlisten(page, 'transitionend', '_onTransitionEnd');
        },

        // prepare the page for animation and add it to the list of pages to be animated
        _initPage: function(node, transition, left) {
          var translate = 'translate3d(' + 0 + 'px,' + 0 + 'px,0)';
          node.style.left = left + "px";
          console.log("left: " + left);
          node.classList.add('iron-swiping');
          node.style.transition = 'none';
          this.transform(translate, node);
          node.style.transition = transition;

          this._animatedPages.push(node);
        },

        _onTrack: function(event) {
          var track = event.detail;

          if (track.state === 'start') {
            this._trackStart(track);
          } else if (track.state === 'track') {
            this._trackMove(track);
          } else if (track.state === 'end') {
            this._trackEnd(track);
          }
        },

        _trackStart: function(trackData) {
          this._setUpCandidatePages();
          this._animatePages(trackData.dx);
        },

        _trackMove: function(trackData) {
          this._animatePages(trackData.dx);
        },

        _trackEnd: function(trackData) {
          // The element is swiped away if it's moved halfway its total width.
          this._swipeComplete = Math.abs(trackData.dx) > this._width * this.threshold;
          this._direction = trackData.dx > 0;
          this._swipeEnd();
        },

        _setUpCandidatePages: function() {
          // reset the animated page list
          this._animatedPages = [];
          // selected page
          this._initPage(this.selectedItem, 'none', 0);
          // left candidate
          this._leftIndex = (Number(this._valueToIndex(this.selected)) - 1 + this.items.length) % this.items.length;
          this._leftCandidate = this.items[ this._leftIndex];
          this._initPage(this._leftCandidate, 'none', -this._width);
          // right candidate
          this._rightIndex = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
          this._rightCandidate = this.items[this._rightIndex];
          this._initPage(this._rightCandidate, 'none', this._width);
        },

        _animatePages: function(x) {
          var translate = 'translate3d(' + x + 'px,' + 0 + 'px,0)';

          for (var i = 0; i < this._animatedPages.length; i++) {
            this.transform(translate, this._animatedPages[i]);
          }
        },

        _computeTransition: function(factor) {
          var result = 'transform ' +
                 factor*this.transitionDuration + 'ms ' +
                 this.transitionTimingFunction;
          console.log(result);
          return result;
        },

        _swipeEnd: function() {
          // Restore the original transition
          for (var i = 0; i < this._animatedPages.length; i++) {
            this._animatedPages[i].style.transition = this._computeTransition(1);
          }

          if (this._swipeComplete) {
            // If the element is ready to be swiped away, then translate it to the full
            // transparency distance.
            this._animatePages(this._direction ? this._width : -this._width);
          } else {
            this._animatePages(0);
          }
        },

        _onTransitionEnd: function(event) {
          this.debounce('transition-end-callback', function() {
            // TODO PG: night use debounce...
            console.log("_onTransitionEnd");

            // remove the iron-swiping class
            for (var i = 0; i < this._animatedPages.length; i++) {
              this._animatedPages[i].classList.remove('iron-swiping');
            }

            if (this._swipeComplete) {
              this.selected = this._direction ? this._indexToValue(this._leftIndex) : this._indexToValue(this._rightIndex);
            } else {
              // ?!?
            }
          }, 300);
        },

        _onSelectedChanged: function(selected) {
          if (this._swipeComplete) {
            // we just need to reset the flag, the transformation happened already
            this._swipeComplete = false;
            console.log("Selected changed by swiping!");
          } else {
            console.log("Initiating transformation by modifying selected!");
            // reset the animated page list
            this._animatedPages = [];
            // in this case, selected has been modify w/o swiping, we need to apply the transformation
            var index = this._valueToIndex(this.selected);
            console.log("index: " + index);
            console.log("this._lastIndex: " + this._lastIndex);
            if (this._lastIndex === undefined) {
              // might happen at init of the component when first selected value is set
              return;
            }
            if (index < this._lastIndex) {
              // we translate to the right
              for (var i = index; i <= this._lastIndex; i++) {
                this._initPage(this.items[i], this._computeTransition(this._lastIndex-index), this._width*(i-this._lastIndex));
              }
            } else {
              // we translate to the left
              for (var j = this._lastIndex; j <= index; j++) {
                this._initPage(this.items[j], this._computeTransition(index-this._lastIndex), this._width*(j-this._lastIndex));
              }
            }
            console.log("translating " + (this._lastIndex - index) * this._width);
            this._animatePages((this._lastIndex - index) * this._width);
          }
          // TODO PG: understand what exactly does notifyResize()...
          this.notifyResize();
          this._lastIndex = this._valueToIndex(this.selected);
        }
      });
    }());
  </script>
</dom-module>
