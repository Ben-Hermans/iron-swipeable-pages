<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../iron-selector/iron-selectable.html">

<!--
An element providing a solution to no problem in particular.

Example:

    <iron-swipeable-pages selected="0">
      <div>One</div>
      <div>Two</div>
      <div>Three</div>
    </iron-swipeable-pages>

@demo demo/index.html
@hero hero.svg
-->

<dom-module id="iron-swipeable-pages">
  <style>
    :host {
      display: block;
      position: relative;
      overflow-x: hidden;
    }
    :host > ::content > * {
      position: absolute;
      top: 0;
      width: 100%;
      height: 100%;
    }
    :host > ::content > :not(.iron-selected):not(.iron-swiping) {
      display: none !important;
    }

    :host > ::content > .iron-swiping {
      pointer-events: none;
    }
  </style>

  <template>
    <content id="content"></content>
  </template>

  <script>
    (function() {
      Polymer({
        is: 'iron-swipeable-pages',

        behaviors: [
          Polymer.IronResizableBehavior,
          Polymer.IronSelectableBehavior
        ],

        properties: {
          // as the selected page is the only one visible, activateEvent
          // is both non-sensical and problematic; e.g. in cases where a user
          // handler attempts to change the page and the activateEvent
          // handler immediately changes it back
          activateEvent: {
            type: String,
            value: null
          },

          /**
           * The value used to decide if a transition is effective and therefore
           * if the page get swiped.
           */
          threshold: {
            type: Number,
            value: 0.3
          },

          /**
           * The CSS transition applied while swiping.
           */
          transition: {
            type: String,
            value: 'transform 300ms cubic-bezier(0.4, 0.0, 0.2, 1)'
          }
        },

        listeners: {
          'iron-items-changed': '_onItemsChanged',
          'track': '_onTrack'
        },

        observers: [
          '_selectedPageChanged(selected)'
        ],

        // Element Lifecycle
        ready: function() {
          this._swipeComplete = false;
          this._transitionProperty = 'transform';
        }, 

        attached: function() {
          this._width = this.offsetWidth;
        },

        // Element Behavior
        _addPage: function(page) {
            if (page.nodeType !== Node.ELEMENT_NODE)
              return;
            this.listen(page, 'transitionend', '_onTransitionEnd');
        },

        _removePage: function(page) {
            if (page.nodeType !== Node.ELEMENT_NODE)
              return;
            this.unlisten(page, 'transitionend', '_onTransitionEnd');
        },

        _onItemsChanged: function(event) {
          var mutations = event.detail;
          for (var i = 0; i < mutations.addedNodes.length; i++) {
            this._addPage(mutations.addedNodes[i]);
          }
          for (var j = 0; j < mutations.removedNodes.length; j++) {
            this._removePage(mutations.removedNodes[j]);
          }
        },

        _selectedPageChanged: function(selected) {
          // TODO PG: it should also be possible to switch imperatively...
          this.async(this.notifyResize);
        },

        _onTrack: function(event) {
          var track = event.detail;

          if (track.state === 'start') {
            this._trackStart(track);
          } else if (track.state === 'track') {
            this._trackMove(track);
          } else if (track.state === 'end') {
            this._trackEnd(track);
          }
        },

        _trackStart: function(trackData) {
          this._setUpCandidateItems();
          this._animate(trackData.dx);
        },

        _trackMove: function(trackData) {
          this._animate(trackData.dx);
        },

        _trackEnd: function(trackData) {
          // The element is swiped away if it's moved halfway its total width.
          // TODO PG: take treshold into account!
          this._swipeComplete = Math.abs(trackData.dx) > this._width / 2;
          this._direction = trackData.dx > 0;
          this._swipeEnd();
        },

        _setUpCandidateItems: function() {
          this._initPage(this.selectedItem, 0);
          // left candidate
          this._leftIndex = (Number(this._valueToIndex(this.selected)) - 1 + this.items.length) % this.items.length;
          this._leftCandidate = this.items[this._leftIndex];
          this._initPage(this._leftCandidate, -this._width);
          // right candidate
          this._rightIndex = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
          this._rightCandidate = this.items[this._rightIndex];
          this._initPage(this._rightCandidate, this._width);
        },

        _initPage: function(node, leftOffset) {
          node.style.transition = 'none';
          node.style.left = leftOffset + "px";
          node.classList.add('iron-swiping');
        },

        _animate: function(x) {
          var translate = 'translate3d(' + x + 'px,' + 0 + 'px,0)';
          console.log("translate: " + translate);

          this.transform(translate, this._leftCandidate);
          this.transform(translate, this.selectedItem);
          this.transform(translate, this._rightCandidate);
        },

        _swipeEnd: function() {
          // Restore the original transition;
          this._leftCandidate.style.transition = this.transition;
          this.selectedItem.style.transition = this.transition;
          this._rightCandidate.style.transition = this.transition;

          if (this._swipeComplete) {
            // If the element is ready to be swiped away, then translate it to the full
            // transparency distance.
            this._animate(this._direction ? this._width : -this._width);
          } else {
            this._animate(0);
          }
        },

        _onTransitionEnd: function(event) {
          this.selectedItem.classList.remove('iron-swiping');
          this._leftCandidate.classList.remove('iron-swiping');
          this._rightCandidate.classList.remove('iron-swiping');

          if (this._swipeComplete) {
            this.selected = this._direction ? this._indexToValue(this._leftIndex) : this._indexToValue(this._rightIndex);
          } else {
            // ?!?
          }
        }
      });
    }());
  </script>
</dom-module>
