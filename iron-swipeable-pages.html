<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../iron-selector/iron-selectable.html">

<!--
An element providing a solution to no problem in particular.

Example:

    <iron-swipeable-pages></iron-swipeable-pages>

Example:

    <iron-swipeable-pages>
      <h2>Hello iron-swipeable-pages</h2>
    </iron-swipeable-pages>

@demo demo/index.html
@hero hero.svg
-->

<dom-module id="iron-swipeable-pages">
  <template>
    <style>
      :host, #container {
        display: block;
        height: 100%;
        width: 100%;
      }
      :host {
        overflow: hidden;
      }
      #container {
        overflow-x : hidden;
        overflow-y: hidden;
        background-color: green;
        transform: translateZ(0);
      }
      #container ::content > * {
        position: relative;
      }
    </style>

    <div id="container" touch-action="pan-y">
      <content id="content"></content>
    </div>
  </template>

  <script>
    Polymer({
      is: 'iron-swipeable-pages',

      behaviors: [
        Polymer.IronResizableBehavior,
        Polymer.IronSelectableBehavior
      ],

      properties: {
        /**
         * The value used to decide if a transition is effective and therefore
         * if the page get swiped.
         */
        threshold: {
          type: Number,
          value: 0.3
        },

        /**
         * The CSS transition applied while swiping.
         */
        transition: {
          type: String,
          value: 'transform 300ms cubic-bezier(0.4, 0.0, 0.2, 1)'
        }
      },

      listeners: {
        'iron-items-changed': '_onItemsChanged',
        'track': '_onTrack',
        'transitionend': '_onTransitionEnd'
      },

      // Element Lifecycle

      ready: function() {
        this._swipeComplete = false;
        this._direction = '';
      }, 

      attached: function() {
        
      },

      // Element Behavior

      _onItemsChanged: function(event) {
        // we should normally simply read the items length...
        console.log("this.items.length: " + this.items.length);
        // instead, look at the mutation details to update the count...

        // try to setup an observer on the items array to see if it triggers...
      },

      _onTrack: function(event) {
        console.log("tracking");
        var target = event.currentTarget;
        var track = event.detail;

        if (track.state === 'start') {
          this._trackStart(track, target);
        } else if (track.state === 'track') {
          this._trackMove(track, target);
        } else if (track.state === 'end') {
          this._trackEnd(track, target);
        }
      },

      _trackStart: function(event, target) {
        // Save the width of the element, so that we don't trigger a style
        // recalc every time we need it.
        this._nodeWidth = target.offsetWidth;
        target.style.transition = 'none';
      },

      _trackMove: function(event, target) {
        this._animate(event.dx, target);
      },

      _trackEnd: function(event, target) {
        // The element is swiped away if it's moved halfway its total width.
        this._swipeComplete = Math.abs(event.dx) > this._nodeWidth / 2;
        this._direction = event.dx > 0;
        this._swipeEnd(target);
      },

      _animate: function(x, target) {
        var direction = x > 0 ? 1 : -1;

        var translate = 'translate3d(' + x + 'px,' + 0 + 'px,0)';

        this.transform(translate, target);
      },

      _swipeEnd: function(target) {
        // Restore the original transition;
        target.style.transition = this.transition;

        if (this._swipeComplete) {
          // If the element is ready to be swiped away, then translate it to the full
          // transparency distance.
          this._animate(this._direction ? this._nodeWidth : -this._nodeWidth, target);
        } else {
          this._animate(0, target);
        }
      },

      _onTransitionEnd: function(event) {
        if (this._swipeComplete) {
          // TODO PG: update selected!
        }
      }
    });
  </script>
</dom-module>
